#! dotfiles v.1
## Common functions

# Simple calculator
function calc() {
	local result=""
	result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
	#                       └─ default (when `--mathlib` is used) is 20
	#
	if [[ "$result" == *.* ]]; then
		# improve the output for decimal numbers
		printf "$result" |
		sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
		    -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
		    -e 's/0*$//;s/\.$//'   # remove trailing zeros
	else
		printf "$result"
	fi
	printf "\n"
}

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$@"
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}

# misc function creates a box around some text.
box(){ c=${2-=}; l=$c$c${1//?/$c}$c$c; echo -e "$l\n| $1 |\n$l"; unset c l;}

# Cleanup the known_hosts when needed.
cleanssh() {
    # Remove the line matching $1 from ~/.ssh/known_hosts.
    # next: if line # or host not exist, then complain
    # USAGE
    if [ "$1" == "" ]
    then
        echo "Usage: enter line # or hostname to remove from .ssh/known_hosts"
        echo "Line # should start with ':'"
        return 1 
    fi
    # backup
    mv $HOME/.ssh/known_hosts $HOME/.ssh/known_hosts.bak
    # sleep 3
    remove=`echo "$1" | tr -d ':'`
    echo Will remove: $remove ...
    while true
    do
    case "$1" in
    :[0-9]*)	echo "removing line #$remove..."
            sed ''$remove'd' $HOME/.ssh/known_hosts.bak > $HOME/.ssh/known_hosts
            break ;;
    *)  	echo "removing host $1..."
            grep -v $1 $HOME/.ssh/known_hosts.bak >$HOME/.ssh/known_hosts
            break ;;
    esac
    done
}

# Check the uptime of the system
checkUptime() {
    # next fix determine from print $4 if listing in days
    # show the uptime if greater than $1 days
    # USAGE 
    if [ "$1" == "" ]
    then
        local upCheck=0
    else
        local upCheck="$1"    
    fi
    local myWhich="`which uptime`"
    if [ "$myWhich" != null ]
    then
        # if awk $4 = days, then continue else we were recently rebooted
        if [ "`uptime | sed -e s/,//g | awk '{print $4}'`" == "days" ]
        then
            {
            #echo foo
            if [ `uptime | sed -e s/,//g | awk '{print $3}'` -ge $upCheck ] 
            then
                box "`uptime`"
            else
                #echo "Up for `uptime | awk '{print $1}'`"
                return 0;
            fi
            }
        else
            return 0;
        fi
    fi
}

findDotFiles() {
# maybe better to use find?
# find ~ -type d -maxdepth 3 -name dotfiles -print
if [ -d $HOME/dotfiles ] || [ -h $HOME/dotfiles ]
then
{
dotPath="$HOME/dotfiles"
}
else
{
if [ -d $HOME/Documents/dotfiles ]
then
{
dotPath="$HOME/Documents/dotfiles"
}
else
{
if [ -d $HOME/Documents/Git/dotfiles ]
then
{
dotPath="$HOME/Documents/Git/dotfiles"
}
else
{
echo "dotfiles directory not found."
break
}
fi
}	
fi
}
fi

export dotPath
}

updatedotfiles() {

bash $dotPath/./bootstrap.sh $1

}

checkRemoteCommit() {
# can be slow over the network
# would llike to have this run
# when printing version in bash_profile
# and compare the local, but maybe later

git --git-dir $dotPath/.git --work-tree=$dotPath ls-remote origin -h refs/heads/master | awk '{print substr($1,1,7)  ".." substr($1,length($1)-6) }'

}

###

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

# Create a data URL from a file
#function dataurl() {
#	local mimeType=$(file -b --mime-type "$1")
#	if [[ $mimeType == text/* ]]; then
#		mimeType="${mimeType};charset=utf-8"
#	fi
#	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
#}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
#function phpserver() {
#	local port="${1:-4000}"
#	local ip=$(ipconfig getifaddr en1)
#	sleep 1 && open "http://${ip}:${port}/" &
#	php -S "${ip}:${port}"
#}

# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c < "$1")
	local gzipsize=$(gzip -c "$1" | wc -c)
	local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
#function httpcompression() {
#	encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
#}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
#function json() {
#	if [ -t 0 ]; then # argument
#		python -mjson.tool <<< "$*" | pygmentize -l javascript
#	else # pipe
#		python -mjson.tool | pygmentize -l javascript
#	fi
#}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	echo # newline
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	echo # newline
}